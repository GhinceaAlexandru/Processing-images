declare namespace ImageProcessing {

  export interface AtlasInputNotResolved {
    files: {
      path: string | string[],
      convertOption: ConvertOptions
    }[],
    layoutConfig: ILayoutConfig,
    exportConfig: SpritesheetExportConfig,
  }

  export interface ConvertOptions {
    scaleX?: number,
    scaleY?: number,
    dontExtent?: boolean,
    maxWidth?: number,
    maxHeight?: number,
    trim?: boolean
  }

  export interface ILayoutConfig {
    max_width: number;
    max_height: number;
    padding: number;
    oversized_warning: boolean;
  }

  export interface SpritesheetExportConfig {
    ext?: 'jpeg' | 'png',
    quality?: number,
    compressor?: (Buffer) => Buffer,
  }

  export interface IGenerateOptions {
    concurrencyLimit: number,
    cleanCache: boolean,
    cleanOutput: boolean,
    inputPath: string,
    outputPath: string,
    cachePath: string,
    outputDestination: (atlasIndex: number, pageIndex: number, res: IGeneratorOutput) => string,
    sriteNameResolver: (atlasIndex: number, path: string, res: IGeneratorOutput) => string,
    atlasPageImagePathResolver: (atlasIndex: number, pageIndex: number, res: IGeneratorOutput) => string,
    atlasPageMetaPathResolver: (atlasIndex: number, pageIndex: number, res: IGeneratorOutput) => string
  }

  export interface AtlasOutput {
    sheets: {
      sprites: LoadingInformation[],
      path: string,
      hash: string
      width: number,
      height: number,
    }[]
  }

  export interface IGeneratorOutput {
    atlases: AtlasOutput[]
  }

  export interface LoadingInformation {
    path: string,
    position: {
      x: number,
      y: number
    },
    dimension: {
      w: number,
      h: number
    },
    trim: {
      x: number,
      y: number,
      w: number,
      h: number,
    }
  }

  export interface Logger {
    assert(value: any, message?: string, ...optionalParams: any[]): void;

    error(message?: any, ...optionalParams: any[]): void;

    info(message?: any, ...optionalParams: any[]): void;

    log(message?: any, ...optionalParams: any[]): void;

    trace(message?: any, ...optionalParams: any[]): void;

    warn(message?: any, ...optionalParams: any[]): void;
  }

  export function promisify<T>(f: (cb: (err: any, res: T) => void) => void, thisContext?: any): () => Promise<T>;

  export function metapacker(atlases: AtlasInputNotResolved[],
                             generateOptions: IGenerateOptions,
                             log: Logger, options: {
      saver: 'PIXIManifestSaver',
      imageProcessor: 'ImageMagickImageProcessor',
      imageProcessorOptions?: any,
    }): Promise<IGeneratorOutput>;



  export type Stats =  {
    width: number;
    height: number;
  };

  export interface ImageStatsProcessor {

    process(filePath: string): Promise<Stats>;
  }

  export function getImageStatsProcessor(generateOptions: {
                                           cleanCache: boolean,
                                           cachePath: string
                                         },
                                         log: Logger, options: {
      saver: 'PIXIManifestSaver',
      imageProcessor: 'ImageMagickImageProcessor',
      imageProcessorOptions?: any,
    }): Promise<ImageStatsProcessor>
}
