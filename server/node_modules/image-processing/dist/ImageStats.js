"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs-extra");
var crypto = require("crypto");
var path = require("path");
var Cache_1 = require("./texture-atlas-packer/Cache");
var Promisify_1 = require("./texture-atlas-packer/Promisify");
var ImageMagickImageProcessor_1 = require("./gm-image-processor/ImageMagickImageProcessor");
var ImageStats = (function () {
    function ImageStats(spritePath, cache, imageProcessor) {
        this.cache = cache;
        this.imageProcessor = imageProcessor;
        this.path = spritePath;
    }
    ImageStats.prototype.calculateSize = function () {
        return this.imageProcessor.getSize(this.path);
    };
    ImageStats.prototype.calculateHash = function () {
        var _this = this;
        return Promisify_1.promisify(fs.stat)(this.path)
            .then(function (stat) {
            // stat.mtime.getTime() is not in here because it causes problems with git
            var identifier = _this.path + ' ' + stat.size;
            _this.hash = crypto.createHash('sha1').update(identifier).digest('hex');
        });
    };
    ImageStats.prototype.process = function () {
        var _this = this;
        return this.calculateHash()
            .then(function () { return _this.cache.lookup('ImageStat', _this.hash, function () { return _this.calculateSize(); }); })
            .then(function (stats) { return _this.stats = stats; })
            .then(function () { return _this; });
    };
    return ImageStats;
}());
exports.ImageStats = ImageStats;
var ImageStatsProcessor = (function () {
    function ImageStatsProcessor(cache, imageProcessor, log) {
        this.cache = cache;
        this.imageProcessor = imageProcessor;
        this.log = log;
    }
    ImageStatsProcessor.prototype.process = function (filePath) {
        var _this = this;
        var is = new ImageStats(filePath, this.cache, this.imageProcessor);
        return is.process().then(function () { return is.stats; })
            .then(function (stats) {
            _this.log.log('OK');
            return stats;
        })
            .then(function (stats) {
            // Save in case error occurs during createAndSaveLoadingManifests step
            return _this.cache.save().then(function () { return stats; });
        })
            .catch(function (error) {
            _this.log.error('Error', error);
            throw error;
        });
    };
    return ImageStatsProcessor;
}());
exports.ImageStatsProcessor = ImageStatsProcessor;
function getImageStatsProcessor(generateOptions, log, options) {
    log = log ? log : console;
    log.log('START');
    var impath = path.resolve(__dirname, '../imagemagick/');
    // log.log('path.resolve(__dirname, \'../imagemagick/\')', impath);
    // log.log('__filename', __filename);
    // log.log('__dirname', __dirname);
    var imageProcessor = null;
    if (options.imageProcessor === 'ImageMagickImageProcessor') {
        var opt = Object.assign({
            imageMagick: true,
            appPath: (process.platform === 'darwin') ? '/usr/local/bin/' : impath + '/'
        }, options.imageProcessorOptions);
        imageProcessor = new ImageMagickImageProcessor_1.default(opt);
    }
    var cache = null;
    return Promise.resolve()
        .then(function () {
        // cleanCache
        if (generateOptions.cleanCache) {
            log.info('Cleaning cache folder');
            return fs.remove(generateOptions.cachePath);
        }
    })
        .then(function () {
        // ensurePathsExist
        return Promise.all([
            fs.ensureDir(generateOptions.cachePath)
        ]);
    })
        .then(function () {
        // createCache
        cache = new Cache_1.default(generateOptions.cachePath, log);
        return cache.load();
    })
        .then(function () {
        return new ImageStatsProcessor(cache, imageProcessor, log);
    })
        .catch(function (error) {
        log.error('Error', error);
        throw error;
    });
}
exports.getImageStatsProcessor = getImageStatsProcessor;
//# sourceMappingURL=ImageStats.js.map