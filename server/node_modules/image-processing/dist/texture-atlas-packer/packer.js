"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs-extra");
var glob = require("glob");
var path = require("path");
var Cache_1 = require("./Cache");
var Queue_1 = require("./Queue");
var Promisify_1 = require("./Promisify");
var processor_1 = require("./processor");
function packer(atlases, generateOptions, imageProcessor, processAtlas, log) {
    log = log ? log : console;
    var queue;
    var cache;
    var output;
    return Promise.resolve()
        .then(function () {
        // cleanCache
        if (generateOptions.cleanCache) {
            log.info('Cleaning cache folder');
            return fs.remove(generateOptions.cachePath);
        }
    })
        .then(function () {
        // cleanOutput
        if (generateOptions.cleanOutput) {
            log.info('Cleaning output folder');
            return fs.remove(generateOptions.outputPath);
        }
    })
        .then(function () {
        // ensurePathsExist
        return Promise.all([
            fs.ensureDir(generateOptions.outputPath),
            fs.ensureDir(generateOptions.cachePath)
        ]);
    })
        .then(function () {
        // createCache
        cache = new Cache_1.default(generateOptions.cachePath, log);
        return cache.load();
    })
        .then(function () {
        // createAndProcessGroups
        queue = new Queue_1.default(generateOptions.concurrencyLimit);
    })
        .then(function () {
        var globPromise = Promisify_1.promisify(glob);
        return processor_1.spriteProcess(atlases, queue, cache, imageProcessor, log, function (p) { return globPromise(generateOptions.inputPath ? (generateOptions.inputPath + '/' + p) : p); })
            .then(function (resp) {
            output = resp;
        });
    })
        .then(function () {
        // Save in case error occurs during createAndSaveLoadingManifests step
        return cache.save();
    })
        .then(function () {
        return Promise
            .all(output.atlases.map(function (atlas, atlasIndex) {
            return Promise
                .all(atlas.sheets.map(function (sheet, pageIndex) {
                var p = generateOptions.outputDestination(atlasIndex, pageIndex, output);
                var outputImagePath = path.join(generateOptions.outputPath, p);
                var temp = sheet.path;
                sheet.path = outputImagePath;
                return fs.copy(temp, outputImagePath);
            }));
        }));
    })
        .then(function () {
        // process atlases
        return Promise.all(output.atlases.map(function (atlas, atlasIndex) {
            return processAtlas(atlasIndex, generateOptions, output);
        }));
    })
        .then(function () {
        log.info('Done');
        return output;
    });
}
exports.packer = packer;
//# sourceMappingURL=packer.js.map