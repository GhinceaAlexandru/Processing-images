"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Sprite_1 = require("./Sprite");
var AtlasGroup_1 = require("./AtlasGroup");
function resolvePaths(input, resolver) {
    var atlases = [];
    return Promise
        .all(input.map(function (a) {
        var atlas = {
            files: [],
            layoutConfig: a.layoutConfig,
            exportConfig: a.exportConfig,
        };
        atlases.push(atlas);
        return Promise
            .all(a.files.map(function (file) {
            return resolver(file.path)
                .then(function (arr) {
                arr.map(function (path) {
                    atlas.files.push({
                        path: path,
                        convertOption: file.convertOption
                    });
                });
            });
        }));
    }))
        .then(function () { return atlases; });
}
function resolverExt(arg, resolver) {
    var promises = [];
    if (Array.isArray(arg)) {
        arg.forEach(function (f) {
            promises.push(resolver(f));
        });
    }
    else {
        promises.push(resolver(arg));
    }
    return Promise.all(promises)
        .then(function (arr2) {
        var items = [];
        arr2.map(function (arr1) {
            arr1.map(function (path) {
                items.push(path);
            });
        });
        return items;
    });
}
function spriteProcess(atlasesNR, queue, cache, imageProcessor, log, resolver) {
    var filesToConverts = {};
    var filePaths;
    var sprites;
    var atlasGroups = [];
    var atlases;
    if (!resolver) {
        resolver = function (p) { return Promise.resolve(p); };
    }
    return Promise.resolve()
        .then(function () {
        return resolvePaths(atlasesNR, function (args) {
            return resolverExt(args, resolver);
        });
    })
        .then(function (a) {
        atlases = a;
        atlases.forEach(function (atlas) {
            atlas.files.forEach(function (file) {
                if (!filesToConverts[file.path]) {
                    filesToConverts[file.path] = [];
                }
                var converts = filesToConverts[file.path];
                converts.push(file.convertOption);
            });
        });
        filePaths = Object.keys(filesToConverts);
        // instantiate all Sprite
        sprites = filePaths.map(function (filePath) {
            return new Sprite_1.default(filePath, filesToConverts[filePath], cache, imageProcessor);
        });
    })
        .then(function () {
        // process all Sprite
        return Promise.all(sprites.map(function (sprite) { return sprite.process(queue); }));
    })
        .then(function () {
        // instantiate all AtlasGroup
        atlases.forEach(function (atlas) {
            var scaledSprites = [];
            atlas.files.forEach(function (file) {
                var sprite = sprites.find(function (s) { return s.path === file.path; });
                var scaledSprite = sprite.scaledSprites.find(function (s) { return s.convertOptions === file.convertOption; });
                scaledSprites.push(scaledSprite);
            });
            var atlasGroup = new AtlasGroup_1.default(scaledSprites, atlas.layoutConfig, atlas.exportConfig, cache, imageProcessor, log);
            atlasGroups.push(atlasGroup);
        });
    })
        .then(function () {
        // process all AtlasGroup
        return Promise.all(atlasGroups.map(function (atlasGroup) { return atlasGroup.process(queue); }));
    })
        .then(function () {
        // fill output model
        var output = {
            atlases: []
        };
        atlasGroups.forEach(function (atlasGroup) {
            var sheets = [];
            atlasGroup.spritesheets.forEach(function (spritesheet) {
                sheets.push({
                    sprites: spritesheet.loadingInformation,
                    path: spritesheet.cachedImagePath,
                    hash: spritesheet.hash,
                    width: spritesheet.width,
                    height: spritesheet.height,
                });
            });
            output.atlases.push({ sheets: sheets });
        });
        return output;
    });
}
exports.spriteProcess = spriteProcess;
//# sourceMappingURL=processor.js.map