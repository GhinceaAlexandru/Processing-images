"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs-extra");
var path = require("path");
var Promisify_1 = require("./Promisify");
var Cache = (function () {
    function Cache(tempPath, log) {
        this.filePath = tempPath + '/cache.json';
        this.tempPath = tempPath;
        this.data = {};
        this.log = log;
        this.cacheMissesCurrentlyInProgress = {};
    }
    Cache.prototype.load = function () {
        var _this = this;
        return fs.readFile(this.filePath, 'utf8')
            .then(function (raw) { return _this.data = JSON.parse(raw); })
            .catch(function () {
            // This failure is recoverable (and even expected in case of a cold cache)
            _this.log.info('Using fresh cache for %s', _this.filePath);
        })
            .then(function () { return _this; });
    };
    Cache.prototype.lookup = function (type, key, cacheMissFunction, version) {
        var _this = this;
        version = version || 0;
        if (!this.data[type]) {
            this.data[type] = {};
        }
        var item = this.data[type][key];
        if (item && item.version === version) {
            return Promise.resolve(item.data);
        }
        // This bit of code avoids a race condition between two lookups for the same type/key
        // Without this cacheMissFunction would be called twice
        this.cacheMissesCurrentlyInProgress[type] = this.cacheMissesCurrentlyInProgress[type] || {};
        if (!this.cacheMissesCurrentlyInProgress[type][key]) {
            this.cacheMissesCurrentlyInProgress[type][key] = Promise.resolve()
                .then(function () { return cacheMissFunction(); })
                .then(function (result) {
                delete _this.cacheMissesCurrentlyInProgress[type][key];
                return result;
            });
        }
        return this.cacheMissesCurrentlyInProgress[type][key]
            .then(function (result) {
            // Make sure we're only using serialisable results
            result = JSON.parse(JSON.stringify(result));
            _this.data[type][key] = {
                version: version,
                data: result
            };
            return result;
        });
    };
    Cache.prototype.save = function () {
        return Promisify_1.promisify(fs.writeFile)(this.filePath, JSON.stringify(this.data, null, 4));
    };
    Cache.prototype.getCachePath = function (basename) {
        return path.join(this.tempPath, basename);
    };
    return Cache;
}());
exports.default = Cache;
//# sourceMappingURL=Cache.js.map